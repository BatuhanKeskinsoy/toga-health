"use client";
import React, {
  createContext,
  useContext,
  useRef,
  useState,
  useEffect,
  useCallback,
} from "react";
import Pusher from "pusher-js";
import { baseURL, pusherCluster, pusherKey } from "@/constants";
import api from "@/lib/axios";
import { notificationRead } from "@/lib/services/notification/notificationRead";
import { notificationReadAll } from "@/lib/services/notification/notificationReadAll";
import { getClientToken } from "@/lib/utils/cookies";
import { UserTypes } from "../types/user/UserTypes";
import { NotificationItemTypes } from "@/lib/types/notifications/notificationTypes";

type ChannelEventHandler = (data: any) => void;

interface PusherContextType {
  subscribe: (
    channel: string,
    event: string,
    handler: ChannelEventHandler,
    isPrivate?: boolean
  ) => void;
  unsubscribe: (
    channel: string,
    event: string,
    handler: ChannelEventHandler
  ) => void;
  pusher: Pusher | null;
  notifications: NotificationItemTypes[];
  notificationsLoading: boolean;
  notificationCount: number;
  refetchNotifications: (userId?: string | number) => void;
  markAsRead: (notificationId: string | number) => Promise<void>;
  markAllAsRead: () => Promise<void>;
  updateNotificationCount: (count: number) => void;
  serverUser: UserTypes; // Server user'ƒ± context'te expose et
  updateServerUser: (user: any) => void; // Server user'ƒ± g√ºncellemek i√ßin
}

const PusherContext = createContext<PusherContextType | undefined>(undefined);

export const PusherProvider = ({
  children,
  user: initialServerUser,
}: {
  children: React.ReactNode;
  user?: UserTypes;
}) => {
  const pusherRef = useRef<Pusher | null>(null);
  const [notifications, setNotifications] = useState<NotificationItemTypes[]>(
    []
  );
  const [notificationsLoading, setNotificationsLoading] = useState(false);
  const [notificationCount, setNotificationCount] = useState(
    initialServerUser?.notification_count || 0
  );
  const [serverUser, setServerUser] = useState(initialServerUser);

  // Server user prop'u deƒüi≈ütiƒüinde state'i g√ºncelle
  useEffect(() => {
    setServerUser(initialServerUser);
  }, [initialServerUser]);

  // Server user deƒüi≈ütiƒüinde notification count'u g√ºncelle
  useEffect(() => {
    if (serverUser?.notification_count !== undefined) {
      setNotificationCount(serverUser.notification_count);
    }
  }, [serverUser?.notification_count]);

  // Notification fetch logic (sadece gerektiƒüinde)
  const fetchNotifications = useCallback(async (userId?: string | number) => {
    if (!userId) {
      return;
    }
    setNotificationsLoading(true);
    try {
      const res = await api.get(`/user/notifications`);
      setNotifications(res.data.data);

      // unread_count'u meta'dan al
      if (res.data.meta?.unread_count !== undefined) {
        setNotificationCount(res.data.meta.unread_count);
      }
    } catch (e) {
      console.error("‚ùå PusherContext: Bildirimleri √ßekerken hata:", e);
    } finally {
      setNotificationsLoading(false);
    }
  }, []);

  const refetchNotifications = useCallback(
    (userId?: string | number) => {
      // User ID varsa onu kullan, yoksa server user'ƒ± kullan
      const targetUserId = userId || serverUser?.id;
      if (targetUserId) {
        fetchNotifications(targetUserId);
      }
    },
    [serverUser?.id, fetchNotifications]
  );

  // Pusher setup - sadece user varsa ve token varsa ba≈ülat
  // GE√áƒ∞Cƒ∞ OLARAK KAPALI - Backend d√ºzelince a√ßƒ±lacak

  /* useEffect(() => {
    console.log("üîç PusherContext: Pusher setup ba≈ülatƒ±lƒ±yor...", {
      serverUser: serverUser?.id,
    });

    if (!serverUser?.id) {
      console.log("‚ùå PusherContext: User ID yok, Pusher kapatƒ±lƒ±yor");
      // User yoksa Pusher'ƒ± kapat
      if (pusherRef.current) {
        pusherRef.current.disconnect();
        pusherRef.current = null;
      }
      return;
    }

    const token = getClientToken();
    console.log(
      "üîç PusherContext: Token durumu:",
      token ? token : "Bulunamadƒ±"
    );

    if (!token) {
      console.log("‚ùå PusherContext: Token yok, Pusher kapatƒ±lƒ±yor");
      // Token yoksa Pusher'ƒ± kapat
      if (pusherRef.current) {
        pusherRef.current.disconnect();
        pusherRef.current = null;
      }
      return;
    }

    // Mevcut Pusher'ƒ± kapat
    if (pusherRef.current) {
      console.log("üîç PusherContext: Mevcut Pusher kapatƒ±lƒ±yor");
      pusherRef.current.disconnect();
    }

    console.log("üîç PusherContext: Yeni Pusher instance olu≈üturuluyor...", {
      pusherKey,
      pusherCluster,
      authEndpoint: `${baseURL}/pusher/auth`,
    });

    // Yeni token ile Pusher'ƒ± ba≈ülat (private channel i√ßin auth gerekir)
    const pusher = new Pusher(pusherKey, {
      cluster: pusherCluster,
      authEndpoint: `${baseURL}/pusher/auth`,
      forceTLS: true,
      enabledTransports: ['ws', 'wss'],
      auth: {
        headers: {
          Accept: "application/json",
          Authorization: `Bearer ${token}`,
          "X-User-ID": serverUser.id,
          "Content-Type": "application/x-www-form-urlencoded",
        },
      },
    });

    // Pusher event listener'larƒ± ekle
    pusher.connection.bind("connected", () => {
      console.log("‚úÖ PusherContext: Pusher baƒülandƒ±");
    });

    pusher.connection.bind("disconnected", () => {
      console.log("‚ùå PusherContext: Pusher baƒülantƒ±sƒ± kesildi");
    });

    pusher.connection.bind("error", (error: any) => {
      console.error("‚ùå PusherContext: Pusher hatasƒ±:", error);
      console.error(
        "‚ùå PusherContext: Error details:",
        JSON.stringify(error, null, 2)
      );
    });

    pusherRef.current = pusher;
    console.log("‚úÖ PusherContext: Pusher instance olu≈üturuldu");

    return () => {
      console.log("üîç PusherContext: Pusher cleanup");
      pusher.disconnect();
    };
  }, [serverUser?.id]); // serverUser.id deƒüi≈ütiƒüinde √ßalƒ±≈üƒ±r
 */
  // Notification channel subscription - Pusher'dan sonra
  // GE√áƒ∞Cƒ∞ OLARAK KAPALI - Backend d√ºzelince a√ßƒ±lacak

  /*  useEffect(() => {
    console.log(
      "üîç PusherContext: Notification channel subscription kontrol√º...",
      {
        serverUser: serverUser?.id,
        pusherRef: !!pusherRef.current,
      }
    );

    if (!serverUser || !serverUser.id || !pusherRef.current) {
      console.log(
        "‚ùå PusherContext: Notification channel i√ßin gerekli ko≈üullar saƒülanmƒ±yor"
      );
      setNotificationsLoading(false);
      return;
    }

    const handler = async (data: any) => {
      console.log("üîî PusherContext: Notification event alƒ±ndƒ±:", data);

      // √ñnce notification'larƒ± fetch et
      await fetchNotifications(serverUser.id);

      // Notification count'u g√ºncelle
      try {
        const profileRes = await api.get("/user/profile");
        console.log(profileRes.data.data);
        if (profileRes.data.data?.notification_count !== undefined) {
          setNotificationCount(profileRes.data.data.notification_count);
          console.log(
            "üîç PusherContext: Notification count g√ºncellendi:",
            profileRes.data.data.notification_count
          );
        }
      } catch (error) {
        console.error("Notification count g√ºncelleme hatasƒ±:", error);
      }
    };

    // Private channel kullan (auth gerektirir)
    const channelName = `private-notifications.${serverUser.id}`;
    console.log("üîç PusherContext: Channel subscribe ediliyor:", channelName);

    const channel = pusherRef.current.subscribe(channelName);

    // Channel event listener'larƒ± ekle
    channel.bind("pusher:subscription_succeeded", (data: any) => {
      console.log(
        "‚úÖ PusherContext: Channel subscription ba≈üarƒ±lƒ±:",
        channelName,
        data
      );
    });

    channel.bind("pusher:subscription_error", (error: any) => {
      console.error("‚ùå PusherContext: Channel subscription hatasƒ±:", error);
      console.error(
        "‚ùå PusherContext: Subscription error details:",
        JSON.stringify(error, null, 2)
      );
    });

    // Pusher state deƒüi≈üikliklerini takip et
    pusherRef.current.connection.bind("state_change", (states: any) => {
      console.log("üîç PusherContext: Connection state deƒüi≈üti:", states);
    });

    channel.bind("notification.sent", handler);
    console.log("‚úÖ PusherContext: Notification event listener eklendi");

    return () => {
      console.log("üîç PusherContext: Channel cleanup");
      channel.unbind("notification.sent", handler);
      channel.unsubscribe();
    };
  }, [serverUser?.id, pusherRef.current, fetchNotifications]); */

  const subscribe = useCallback(
    (
      channelName: string,
      eventName: string,
      handler: ChannelEventHandler,
      isPrivate = true
    ) => {
      if (!pusherRef.current) return;
      const channel = pusherRef.current.subscribe(channelName);
      channel.bind(eventName, handler);
    },
    []
  );

  const unsubscribe = useCallback(
    (channelName: string, eventName: string, handler: ChannelEventHandler) => {
      if (!pusherRef.current) return;
      const channel = pusherRef.current.channel(channelName);
      if (channel) channel.unbind(eventName, handler);
    },
    []
  );

  // Mark single notification as read
  const markAsRead = useCallback(
    async (notificationId: string | number) => {
      setNotificationsLoading(true);
      try {
        await notificationRead(String(notificationId));
        await fetchNotifications(serverUser?.id);

        // Notification count'u g√ºncelle
        try {
          const profileRes = await api.get("/user/profile");
          if (profileRes.data.data?.notification_count !== undefined) {
            setNotificationCount(profileRes.data.data.notification_count);
          }
        } catch (error) {
          console.error(
            "‚ùå Mark as read sonrasƒ± notification count g√ºncelleme hatasƒ±:",
            error
          );
        }
      } catch (e) {
        console.error("Bildirim okundu i≈üaretlenirken hata:", e);
      } finally {
        setNotificationsLoading(false);
      }
    },
    [serverUser?.id, fetchNotifications]
  );

  // Mark all notifications as read
  const markAllAsRead = useCallback(async () => {
    setNotificationsLoading(true);
    try {
      await notificationReadAll();
      await fetchNotifications(serverUser?.id);

      // Notification count'u g√ºncelle
      try {
        const profileRes = await api.get("/user/profile");
        if (profileRes.data.data?.notification_count !== undefined) {
          setNotificationCount(profileRes.data.data.notification_count);
        }
      } catch (error) {
        console.error(
          "‚ùå Mark all as read sonrasƒ± notification count g√ºncelleme hatasƒ±:",
          error
        );
      }
    } catch (e) {
      console.error("T√ºm bildirimleri okundu i≈üaretlerken hata:", e);
    } finally {
      setNotificationsLoading(false);
    }
  }, [serverUser?.id, fetchNotifications]);

  // Notification count'u manuel g√ºncellemek i√ßin
  const updateNotificationCount = useCallback((count: number) => {
    setNotificationCount(count);
  }, []);

  // Server user'ƒ± g√ºncellemek i√ßin
  const updateServerUser = useCallback((user: any) => {
    setServerUser(user);
  }, []);

  const contextValue = React.useMemo(
    () => ({
      subscribe,
      unsubscribe,
      pusher: pusherRef.current,
      notifications,
      notificationsLoading,
      notificationCount,
      refetchNotifications,
      markAsRead,
      markAllAsRead,
      updateNotificationCount,
      serverUser,
      updateServerUser,
    }),
    [
      subscribe,
      unsubscribe,
      notifications,
      notificationsLoading,
      notificationCount,
      refetchNotifications,
      markAsRead,
      markAllAsRead,
      updateNotificationCount,
      serverUser,
      updateServerUser,
    ]
  );

  return (
    <PusherContext.Provider value={contextValue}>
      {children}
    </PusherContext.Provider>
  );
};

export const usePusherContext = () => {
  const ctx = useContext(PusherContext);
  if (!ctx)
    throw new Error("usePusherContext must be used within PusherProvider");
  return ctx;
};
